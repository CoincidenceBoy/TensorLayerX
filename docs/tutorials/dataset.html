<!DOCTYPE html>
<html>
<head>
<title>dataset.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8A%A0%E8%BD%BD">数据集定义与加载</h1>
<p>深度学习模型需要大量的数据来完成训练和评估，这些数据样本可能是图片（image）、文本（text）、语音（audio）等多种类型，而模型训练过程实际是数学计算过程，因此数据样本在送入模型前需要经过一系列处理，如转换数据格式、划分数据集、变换数据形状（shape）、制作数据迭代读取器以备分批训练等。</p>
<p>在tensorlayerx框架中，可通过如下两个核心步骤完成数据集的定义与加载：</p>
<ol>
<li>
<p><strong>定义数据集</strong>：将磁盘中保存的原始图片、文字等样本和对应的标签映射到 <code>Dataset</code>，方便后续通过索引（<code>index</code>）读取数据，在 <code>Dataset</code> 中还可以进行一些数据变换、数据增广等预处理操作。在tensorlayerx框架中推荐使用 <code>tensorlayerx.dataflow.Dataset</code> 自定义数据集，另外在 <code>tensorlayerx.files.dataset_loaders</code> 目录下tensorlayerx内置了一些经典数据集方便直接调用。</p>
</li>
<li>
<p><strong>迭代读取数据集</strong>：自动将数据集的样本进行分批（<code>batch</code>）、乱序（<code>shuffle</code>）等操作，方便训练时迭代读取，同时还支持多进程异步读取功能可加快数据读取速度。在tensorlayerx框架中可使用 <code>tensorlayerx.dataflow.DataLoader</code> 迭代读取数据集。</p>
</li>
</ol>
<p>本文以图像数据集为例介绍。</p>
<h2 id="%E4%B8%80%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%9B%86">一、定义数据集</h2>
<h3 id="11-%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E9%9B%86">1.1 直接加载内置数据集</h3>
<p>tensorlayerx框架在 <code>tensorlayerx.files.dataset_loaders</code> 目录下内置了一些经典数据集可直接调用，通过以下代码可查看tensorlayerx框架中的内置数据集。</p>
<pre class="hljs"><code><div>import tensorlayerx
print('计算机视觉（CV）和自然语言处理（NLP）相关数据集：', tensorlayerx.files.dataset_loaders.__all__)
</div></code></pre>
<pre class="hljs"><code><div>计算机视觉（CV）和自然语言处理（NLP）相关数据集： ['load_celebA_dataset',
 'load_cifar10_dataset',
 'load_cyclegan_dataset',
 'load_fashion_mnist_dataset',
 'load_flickr1M_dataset',
 'load_flickr25k_dataset',
 'load_imdb_dataset',
 'load_matt_mahoney_text8_dataset',
 'load_mnist_dataset',
 'load_mpii_pose_dataset',
 'load_nietzsche_dataset']
</div></code></pre>
<p>从打印结果可以看到tensorlayerx内置了 CV 领域的 MNIST、FashionMNIST、Cifar10、flickr1M、flickr25k 等数据集，以及 NLP 领域的 Imdb、nietzsche等数据集。</p>
<p>以 MNIST 数据集为例，加载内置数据集的代码示例如下所示。</p>
<pre class="hljs"><code><div>import tensorlayerx as tlx

X_train, y_train, X_val, y_val, X_test, y_test = tlx.files.load_mnist_dataset(shape=(-1, 28, 28, 1))
X_train = X_train * 255
</div></code></pre>
<p>内置的 MNIST 数据集已经划分好了训练集和测试集。</p>
<p>我们可构建一个子类继承自 tensorlayerx.dataflow.Dataset ，并且实现下面的三个函数：</p>
<ol>
<li>
<p><code>__init__</code>：完成数据集初始化操作，将磁盘中的样本文件路径和对应标签映射到一个列表中。</p>
</li>
<li>
<p><code>__getitem__</code>：定义指定索引（index）时如何获取样本数据，最终返回对应 index 的单条数据（样本数据、对应的标签）。</p>
</li>
<li>
<p><code>__len__</code>：返回数据集的样本总数。</p>
</li>
</ol>
<pre class="hljs"><code><div>
from tensorlayerx.dataflow import Dataset
from tensorlayerx.vision.transforms import Normalize, Compose

class MNISTDataset(Dataset):
    &quot;&quot;&quot;
    步骤一：继承 tensorlayerx.dataflow.Dataset 类
    &quot;&quot;&quot;

    def __init__(self, data=X_train, label=y_train, transform=transform):
        &quot;&quot;&quot;
        步骤二：实现 __init__ 函数，初始化数据集，将样本和标签映射到列表中
        &quot;&quot;&quot;

        self.data_list = data
        self.label = label
        self.transform = transform

    def __getitem__(self, index):
        &quot;&quot;&quot;
        步骤三：实现 __getitem__ 函数，定义指定 index 时如何获取数据，并返回单条数据（样本数据、对应的标签）
        &quot;&quot;&quot;

        image = self.data_list[index].astype('float32')
        image = self.transform(image)
        label = self.label[index].astype('int64')

        return image, label

    def __len__(self):
        &quot;&quot;&quot;
        步骤四：实现 __len__ 函数，返回数据集的样本总数
        &quot;&quot;&quot;

        return len(self.data_list)


transform = Compose([Normalize(mean=[127.5], std=[127.5], data_format='HWC')])
train_dataset = MNISTDataset(data=X_train, label=y_train, transform=transform)
</div></code></pre>
<p>在上面的代码中，自定义了一个数据集类 <code>MNISTDataset</code> ， <code>MNISTDataset</code> 继承自 <code>tensorlayerx.dataflow.Dataset</code> 基类 ，并且实现了 <code>__init__</code>,<code>__getitem__</code> 和 <code>__len__</code> 三个函数。</p>
<ul>
<li>
<p>在 <code>__init__</code> 函数中完成了对标签文件的读取和解析，并将所有的图像路径 <code>image_path</code> 和对应的标签 label 存放到一个列表 <code>data_list</code> 中。</p>
</li>
<li>
<p>在 <code>__getitem__</code> 函数中定义了指定 index 获取对应图像数据的方法，完成了图像的读取、预处理和图像标签格式的转换，最终返回图像和对应标签 <code>image</code>, <code>label。</code></p>
</li>
<li>
<p>在 <code>__len__</code> 函数中返回 <code>__init__</code> 函数中初始化好的数据集列表 <code>data_list</code> 长度。</p>
</li>
</ul>
<p>另外，在 <code>__init__</code> 函数和 <code>__getitem__</code> 函数中还可实现一些数据预处理操作，如对图像的翻转、裁剪、归一化等操作，最终返回处理好的单条数据（样本数据、对应的标签），该操作可增加图像数据多样性，对增强模型的泛化能力带来帮助。tensorlayerx框架在 <code>tensorlayerx.vision.transforms</code> 下内置了几十种图像数据处理方法，详细使用方法可参考 <a href="data_processing.md">数据预处理</a> 章节。</p>
<p>和内置数据集类似，可以使用下面的代码直接对自定义数据集进行迭代读取。</p>
<pre class="hljs"><code><div>from matplotlib import pyplot as plt

for data in train_dataset:
    image, label = data
    print('shape of image: ',image.shape)
    plt.title(str(label))
    plt.imshow(image[:,:,0])    
    break
</div></code></pre>
<pre class="hljs"><code><div>shape of image:  (28, 28, 1)
</div></code></pre>
<p><img src="images/dataset_mnist.png" alt=""></p>
<h2 id="%E4%BA%8C%E8%BF%AD%E4%BB%A3%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E9%9B%86">二、迭代读取数据集</h2>
<h3 id="21-%E4%BD%BF%E7%94%A8-tensorlayerxdataflowdataloader-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E5%99%A8">2.1 使用 tensorlayerx.dataflow.DataLoader 定义数据读取器</h3>
<p>通过前面介绍的直接迭代读取 Dataset 的方式虽然可实现对数据集的访问，但是这种访问方式只能单线程进行并且还需要手动分批次（batch）。在飞桨框架中，推荐使用 tensorlayerx.dataflow.DataLoader API 对数据集进行多进程的读取，并且可自动完成划分 batch 的工作。</p>
<pre class="hljs"><code><div># 定义并初始化数据读取器
train_loader = tlx.dataflow.DataLoader(train_dataset, batch_size=64, shuffle=True)

# 调用 DataLoader 迭代读取数据
for batch_id, data in enumerate(train_loader):
    images, labels = data
    print(&quot;batch_id: {}, 训练数据shape: {}, 标签数据shape: {}&quot;.format(batch_id, images.shape, labels.shape))
    break
</div></code></pre>
<pre class="hljs"><code><div>batch_id: 0, 训练数据shape: [64, 28, 28, 1], 标签数据shape: [64]
</div></code></pre>
<p>通过上述方法，初始化了一个数据读取器 train_loader，用于加载训练数据集 custom_dataset。在数据读取器中几个常用的字段如下：</p>
<ul>
<li>
<p><code>batch_size</code>：每批次读取样本数，示例中 batch_size=64 表示每批次读取 64 个样本。</p>
</li>
<li>
<p><code>shuffle</code>：样本乱序，示例中 shuffle=True 表示在取数据时打乱样本顺序，以减少过拟合发生的可能。</p>
</li>
</ul>
<p>定义好数据读取器之后，便可用 for 循环方便地迭代读取批次数据，用于模型训练了。值得注意的是，如果使用高层 API 的 <code>tlx.model.Model.train</code> 读取数据集进行训练，则只需定义数据集 <code>Dataset</code> 即可，不需要再单独定义 <code>DataLoader</code>，因为 <code>tlx.model.Model.train</code> 中实际已经封装了一部分 <code>DataLoader</code> 的功能，详细可参考 模型训练、评估与推理 章节。</p>
<p>注： <code>DataLoader</code> 实际上是通过批采样器 <code>BatchSampler</code> 产生的批次索引列表，并根据索引取得 <code>Dataset</code> <code>中的对应样本数据，以实现批次数据的加载。DataLoader</code> 中定义了采样的批次大小、顺序等信息，对应字段包括 <code>batch_size</code>、<code>shuffle</code>。这两个字段也可以用一个 batch_sampler 字段代替，并在 batch_sampler 中传入自定义的批采样器实例。以上两种方式二选一即可，可实现相同的效果。下面小节中介绍后一种自定义采样器的使用方法，该用法可以更灵活地定义采样规则。</p>
<h2 id="%E4%B8%89%E6%80%BB%E7%BB%93">三、总结</h2>
<p>本节中介绍了在飞桨框架中将数据送入模型训练之前的处理流程。<br>
主要包括定义数据集和定义数据读取器两个步骤，另外在数据读取器中可调用采样器实现更灵活地采样。其中，在定义数据集时，本节仅对数据集进行了归一化处理，如需了解更多数据增强相关操作，可以参考 <a href="data_processing.md">数据预处理</a> 章节。</p>
<p>以上所有数据处理工作完成后，即可进入下一个任务：模型训练、评估与推理。</p>

</body>
</html>
